# 移动端-数据分析平台
项目描述：该项目是一款移动端的 SaaS 化商业智能系统，基于海量的京东广告数据为各事业部总监，分析师提供多维数据分析、监控服务，包含卡片趋势图、数据上卷下钻及看板等功能，曾获得营销中心最佳项目。

技术栈：Vue3 + Vuex + Vant + AntV + TypeScript + Jest

个人职责：

- 负责首屏优化，使用 Performance 统计长任务拆分、组件异步等优化效果，首屏时间由4~8s减少至1~3s。
- 负责查数流程性能优化，通过请求链路、代码及打包优化等方式，实时与离线指标的页面加载耗时减少60%。
- 负责数据上卷下钻，监控看板等模块的开发和维护，解决移动端适配和操作系统的兼容性。
- 基于 Jest 对时间组件、查数操作等核心流程添加自动化测试，重要函数的单元测试覆盖率达到75%。
- 基于 Vant 封装农历日期组件并沉淀至前端组件库，支持日、月、自定义等各日期粒度的查数能力。


## 开屏优化怎么做
1. 背景：卡顿
2. 排查问题
通过 Performance 工具 及 Performance moniter 监控网络状态、CPU占用###评价指标
我将性能指标分为以用户为中心的性能指标和以技术为中心的性能指标
### 用户：
- 白屏事件：FP 首次绘制：页面视觉首次发生变化的时间点。比如设置的body背景色；FP不包含默认背景绘制，但包含非默认的背景绘制。
- 首屏事件：FCP首次内容绘制：首次绘制任何文本、图像、非空白canvas或者SVG的时间点。用户最关注的时间点400ms)(890ms!
- LCP 最大内容绘制，LCP是页面内首次开始加载的时间点，到可视区域内最大的图像或者文本块完成渲染 的相对时间，是用户主观感知到的页面加载速度，因为最大内容绘制完成时，往往可以认为 页面将要加载完成( 3 . 8 5 \Rightarrow 1 . 3 5 )
### 技术：
- W3C Performance Timeline Level 2 的模型图，图中很多的时间点、时间段，对于用户来说或许并不需要知道，但是，对于技术人员来说，采集其中有意义的时间段，可以让我们从精确数据的角度对网站的性能有一个判断。
- DCL（DOMContentLoaded）：表示文档的初始 HTML 被完全加载和解析完成，且没有等待样式表、图像和子框架的加载。此事件在大部分页面结构已经完全就绪时触发，适合进行一些初步操作。
- L（Load）；页面加载完成事件。当页面所有资源（如图像、样式表、脚本等）都完成加载时触发。这个事件表示页面已经完全就绪可供用户交互。
- CPU：浏览器进程及其子进程的 CPU 使用情况
### 优化策略
产品、代码、网络、渲染、打包这几个角度
- 产品：产品交互优化（loading）、非必要代码下线
- 代码：长任务拆分、组件异步加载、减少白屏时间
-  网络：Performance 、Performance moniter、CDN
- 项目资源；js async、Lighthouse Treemap

## 具体做了啥
1. 白屏时间长：等到首页所有模块加载完毕，首页才展示
- 方案：添加loading蒙层，之后再展示页面框架，最后再展示卡片和趋势图长任务拆分
- 首屏加载，仅加载最少的js代码，js- sdk使用async
- 维度接口、卡片和趋势图接口普遍要1s返回，通过接口拆分，只保留加载首页必须的接口，其余数据闲时加载，减少对主线程的阻塞。
2. 配置化数据接口合并及异步拆分闲时加载维度筛选相关的逻辑处理（2s到300ms）
  1. 维度筛选数据结构递归+深拷贝，导致了主线程被阻塞，CPU占用高，JSON.stringify（JSON.parse（），时间减少5—10倍，改为栈存储，空间换时间；Array.map循环换成了for循环；
  2. vue响应式数据处理，通过toRaw转成非响应式数据，减少依赖收集及监听
  3. 全局监听多，维度返回后：时间组件渲染，将全局时间拆分，减少watch监听造成时间组件的频繁渲染；卡片趋势图无数据状态过早渲染
  4. 接口体积大：接口拆分；字段精简
3. 组件异步加载
   - 问题：首页暂不需要加载组件也在初始化加载了：涉及上卷下钻组件、指标对比趋势图、进度监控等组件初始化加载
   - 方案：资源懒加载vue3-defineAsyncComponent、插件按需引入 图片和打包后的静态资源上传OSS，并开启CDN缓存
### 还有哪些优化点
1. 第三方依赖优化：Lodash-es （ESM 通过Lighthouse Treenap 资源包分析发现，lodash、Moment的js体积占用偏大，替换更轻量更强大的dayjs
- webView的离线包
- 浏览器缓存
- http2
2. 渲染
- vant和antv组件存在大量重排重绘
- 看板渲染优化，现在是一次性渲染10套，切换数据再渲染
- 虚拟滚动与懒加载 （500ms的收益）
3. 预加载
4. 复杂动画使用 will-change: transform 启用硬件加速，通过GPU提升渲染性能


## 如何继续提升 FCP 指标
提升 FCP （First Contentful Paint，首次内容绘制）的性能是优化网页加载速度和用户体验的重要方面。
以下是一些常见的方法和策略来改善 FCP：
1. 优化资源加载：
- 減少阻塞渲染的CSS 和 JavaScript
- 将 CSS 放在 <head> 中，以确保它尽快加载和解析。
- 使用 async defer 属性加载非关键的 JavaScript，从而不会阻塞 HTML解析。
内联关键CSS：
- 对于关键的 CSS，考虑将其内联到 HTML 中，以便浏览器可以立即渲染页面的关键部分。
2. 减少和优化资源大小：
- 压缩和最小化 CSS 和 JavaScript：使用工具（如 Terser、UglifyJS、CSSNano）来压缩和最小化文件大小。
3. 优化图像：使用现代图像格式（如 WebP）和工具（如 ImageOptim、TinyPNG）来压缩图像;考虑使用响应式图像技术，根据设备显示合适大小的图像。
4. 使用内容分发网络（CDN）：
- 将资源托管在 CDN上，利用其全球分布的服务器来加速资源传递，诚少延迟。
5. 减少服务器响应时间；
- 优化服务器性能，减少生成和传递 HTML 文档的时间。
- 使用缓存技术（如 HTTP 缓存、Redis 缓存）加速服务器响应。
6. 优先加载关键资源：
- 使用
‹link rel="preload">来提前加载关键资源（如字体、重要图片），确保它们在需要时已准备
就緒。
7. 确保 HTML 中的关键资源按优先级顺序加载。
1. 减少请求数量
-使用 HTTP/2 来并行加载多个资源，诚少请求的开销。
1. 启用浏览器缓存：
- 通过设置适当的缓存头：（如 Cache-Contro1）来利用浏览器缓存，诚少重复请求。

## FCP和LCP等性能指标如何采集
- 通过浏览器的 API: Performance.getEntriesByType
1. 通过performance.getEntriesByType（'paint'），取第二个paint的时间，或者通过Mutation Observer观察到首次节点变动的时间。
2. 使用 performance.getEntriesByType（'largest-contentful-paint'）方法来获取
LCP 的相关信息
- 谷歌提供的插件库 webVitals的getFCP, getLCP 这些API

## 如何解决移动端样式及功能兼容性问题，难点啥的
移动端适配主要就分为两方面，一方面要适配不同机型的屏幕尺寸（安全区域+动态 Viewport 与一方面是对细节像素的处理过程。
REM适配），
1. 屏幕适配
我了解的屏幕适配方案有三种。
1. rem 结合视口范围设置rem的基准值=>原理就是设置根目录HTML元素的字体大小，比如说font-size
为100px，则1rem就为100px 优点就是系统整体自适应，配置简单
2. transform:scale等比缩放=>根据屏幕大小，对图表进行整体的等比缩放，使用于一些交互元素的缩放
3. vw/wh 根据视口大小来确定大小的=>每个图表都需要单独做字体、间距、位移
适配移动端参考阿里 flexible 库的适配方案
1. 使用 rem 模拟 vw 特性适配多种屏幕尺寸
1. 控制 viewport 的 width 和 scale 值适配高倍屏显示
### 自适应布局
- 结合J5依据屏幕宽度与设计图宽度的比例动态声明<html>的font-size，以rem为长度单位声明所有节点的几何属性，这样就能做到大部分移动设备的页面兼容，兼容出入较大的地方再通过媒体查询做特别处理。


### 安全区域
针对全面屏的刘海，返回按钮，为了防止被遮挡需要设置安全区域
- <meta name="viewport" content="viewport-fit=cover”›告诉浏览器在渲染网页时，应该覆盖整个屏幕，包括那些有缺口或圆角的区域。
- 针对ios 11.2 需要做兼容性处理

```css
/* 设置下边安全距离 */
body {
padding-bottom: constant (safe-area-inset-bottom);
padding-bottom: env（safe-area-inset-bottom）；
```

### 难点：各种机型的功能异常或兼容性问题
-确定核心机型：通过埋点数据，确定需要兼容的主要机型。ios/vivo/华为，测试阶段增加各种真机测试
- 遇到过哪些问题
  - ios11的安全位置兼容
  - 横竖屏
  - 左滑返回首页


## 说说前端代码质量提升
### 自动化测试
# S
1. 日期组件作京算盘项目中一块极重要的业务组件，业务逻辑细节多
2. 每次对日期组件的升级选代都将复测所有的組件功能，开发及测试的人力投入大
# T
1.前端代码质量保障
# A
- 框架选型：jest，零配置、内置断言库、并行测试以及社区成熟
- 衡量指标：行、函数、分支、语句覆盖率75%
- 测试策略的确定：对公共核心函数（例如：公农历转换）.及日期组件编写测试用例
- 单测的集成及部署，每次部署代码自动测试，不通过不允许部暑
https://cloud.baidu.com/article/3234156

### 问题：
- 兼容性升级为 Vue3 后与Jest版本需要对应
- 性能问题
测试速度慢：通过 jest --maxWlorkers=50%
- Jest 无法处理CommonJ5模块，配置文件中启用对ES Modules的支持，或者使用Babel等工具将ES Modules 转参数来调整工作线程的数量
- 减少依赖；
过多的依赖项：导致测试速度变慢。解决方案是使用jest.mock（）函数来模拟依赖项，以減少不必要的加载时间。jest.requireActual允许你在使用 Jest的自动模拟功能时，选择性地访问模块的真实实现

### 代码review规范
### S
- 代码review人力成本高，耗时且细节问题不容易发现
- 通过代码规范eos及ai评审提升代码评审效率
# T
- 通过规范流程，避免本地禁用eslint，review不仔细时的一些错误代码被提测或上线
- 接入ai代码review，实现思路
  1. 触发评审；Coding 平台 发起 menger 操作后，触发webhook触发流水线
  2. 获取代码DIFF信息：流水线的脚本使用 Coding API 获取 Pull Request （PR） 的信息，  包括代码的diff 详情
  3. GPT分析：将代码 diff 内容提供给 GPT 模型，并将得到代码评审结论
  4. 输出评审意见：将评审意见通过 Coding API 提交到 Coding 评论区